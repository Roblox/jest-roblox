-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/test/stars.js

return function()
	local CurrentModule = script.Parent
	local PicomatchModule = CurrentModule.Parent

	local isMatch = require(PicomatchModule).isMatch
	describe("stars", function()
		describe("issue related", function()
			it("should respect dots defined in glob pattern (micromatch/#23)", function()
				assert(isMatch("z.js", "z*"))
				assert(not isMatch("zzjs", "z*.js"))
				assert(not isMatch("zzjs", "*z.js"))
			end)
		end)

		describe("single stars", function()
			it("should match anything except slashes and leading dots", function()
				assert(not isMatch("a/b/c/z.js", "*.js"))
				assert(not isMatch("a/b/z.js", "*.js"))
				assert(not isMatch("a/z.js", "*.js"))
				assert(isMatch("z.js", "*.js"))
				assert(not isMatch("a/.ab", "*/*"))
				assert(not isMatch(".ab", "*"))
				assert(isMatch("z.js", "z*.js"))
				assert(isMatch("a/z", "*/*"))
				assert(isMatch("a/z.js", "*/z*.js"))
				assert(isMatch("a/z.js", "a/z*.js"))
				assert(isMatch("ab", "*"))
				assert(isMatch("abc", "*"))
				assert(not isMatch("bar", "f*"))
				assert(not isMatch("foo", "*r"))
				assert(not isMatch("foo", "b*"))
				assert(not isMatch("foo/bar", "*"))
				assert(isMatch("abc", "*c"))
				assert(isMatch("abc", "a*"))
				assert(isMatch("abc", "a*c"))
				assert(isMatch("bar", "*r"))
				assert(isMatch("bar", "b*"))
				assert(isMatch("foo", "f*"))
			end)

			it("should match spaces", function()
				assert(isMatch("one abc two", "*abc*"))
				assert(isMatch("a         b", "a*b"))
			end)

			it("should support multiple non-consecutive stars in a path segment", function()
				assert(not isMatch("foo", "*a*"))
				assert(isMatch("bar", "*a*"))
				assert(isMatch("oneabctwo", "*abc*"))
				assert(not isMatch("a-b.c-d", "*-bc-*"))
				assert(isMatch("a-b.c-d", "*-*.*-*"))
				assert(isMatch("a-b.c-d", "*-b*c-*"))
				assert(isMatch("a-b.c-d", "*-b.c-*"))
				assert(isMatch("a-b.c-d", "*.*"))
				assert(isMatch("a-b.c-d", "*.*-*"))
				assert(isMatch("a-b.c-d", "*.*-d"))
				assert(isMatch("a-b.c-d", "*.c-*"))
				assert(isMatch("a-b.c-d", "*b.*d"))
				assert(isMatch("a-b.c-d", "a*.c*"))
				assert(isMatch("a-b.c-d", "a-*.*-d"))
				assert(isMatch("a.b", "*.*"))
				assert(isMatch("a.b", "*.b"))
				assert(isMatch("a.b", "a.*"))
				assert(isMatch("a.b", "a.b"))
			end)

			it("should support multiple stars in a segment", function()
				assert(not isMatch("a-b.c-d", "**-bc-**"))
				assert(isMatch("a-b.c-d", "**-**.**-**"))
				assert(isMatch("a-b.c-d", "**-b**c-**"))
				assert(isMatch("a-b.c-d", "**-b.c-**"))
				assert(isMatch("a-b.c-d", "**.**"))
				assert(isMatch("a-b.c-d", "**.**-**"))
				assert(isMatch("a-b.c-d", "**.**-d"))
				assert(isMatch("a-b.c-d", "**.c-**"))
				assert(isMatch("a-b.c-d", "**b.**d"))
				assert(isMatch("a-b.c-d", "a**.c**"))
				assert(isMatch("a-b.c-d", "a-**.**-d"))
				assert(isMatch("a.b", "**.**"))
				assert(isMatch("a.b", "**.b"))
				assert(isMatch("a.b", "a.**"))
				assert(isMatch("a.b", "a.b"))
			end)

			it("should return true when one of the given patterns matches the string", function()
				assert(isMatch("/ab", "*/*"))
				assert(isMatch(".", "."))
				assert(not isMatch("a/.b", "a/"))
				assert(isMatch("/ab", "/*"))
				assert(isMatch("/ab", "/??"))
				assert(isMatch("/ab", "/?b"))
				assert(isMatch("/cd", "/*"))
				assert(isMatch("a", "a"))
				assert(isMatch("a/.b", "a/.*"))
				assert(isMatch("a/b", "?/?"))
				assert(isMatch("a/b/c/d/e/j/n/p/o/z/c.md", "a/**/j/**/z/*.md"))
				assert(isMatch("a/b/c/d/e/z/c.md", "a/**/z/*.md"))
				assert(isMatch("a/b/c/xyz.md", "a/b/c/*.md"))
				assert(isMatch("a/b/c/xyz.md", "a/b/c/*.md"))
				assert(isMatch("a/b/z/.a", "a/*/z/.a"))
				assert(not isMatch("a/b/z/.a", "bz"))
				assert(isMatch("a/bb.bb/aa/b.b/aa/c/xyz.md", "a/**/c/*.md"))
				assert(isMatch("a/bb.bb/aa/bb/aa/c/xyz.md", "a/**/c/*.md"))
				assert(isMatch("a/bb.bb/c/xyz.md", "a/*/c/*.md"))
				assert(isMatch("a/bb/c/xyz.md", "a/*/c/*.md"))
				assert(isMatch("a/bbbb/c/xyz.md", "a/*/c/*.md"))
				assert(isMatch("aaa", "*"))
				assert(isMatch("ab", "*"))
				assert(isMatch("ab", "ab"))
			end)

			it("should return false when the path does not match the pattern", function()
				assert(not isMatch("/ab", { "*/" }))
				assert(not isMatch("/ab", { "*/a" }))
				assert(not isMatch("/ab", { "/" }))
				assert(not isMatch("/ab", { "/?" }))
				assert(not isMatch("/ab", { "/a" }))
				assert(not isMatch("/ab", { "?/?" }))
				assert(not isMatch("/ab", { "a/*" }))
				assert(not isMatch("a/.b", { "a/" }))
				assert(not isMatch("a/b/c", { "a/*" }))
				assert(not isMatch("a/b/c", { "a/b" }))
				assert(not isMatch("a/b/c/d/e/z/c.md", { "b/c/d/e" }))
				assert(not isMatch("a/b/z/.a", { "b/z" }))
				assert(not isMatch("ab", { "*/*" }))
				assert(not isMatch("ab", { "/a" }))
				assert(not isMatch("ab", { "a" }))
				assert(not isMatch("ab", { "b" }))
				assert(not isMatch("ab", { "c" }))
				assert(not isMatch("abcd", { "ab" }))
				assert(not isMatch("abcd", { "bc" }))
				assert(not isMatch("abcd", { "c" }))
				assert(not isMatch("abcd", { "cd" }))
				assert(not isMatch("abcd", { "d" }))
				assert(not isMatch("abcd", { "f" }))
				assert(not isMatch("ef", { "/*" }))
			end)

			it("should match a path segment for each single star", function()
				assert(not isMatch("aaa", "*/*/*"))
				assert(not isMatch("aaa/bb/aa/rr", "*/*/*"))
				assert(not isMatch("aaa/bba/ccc", "aaa*"))
				assert(not isMatch("aaa/bba/ccc", "aaa**"))
				assert(not isMatch("aaa/bba/ccc", "aaa/*"))
				assert(not isMatch("aaa/bba/ccc", "aaa/*ccc"))
				assert(not isMatch("aaa/bba/ccc", "aaa/*z"))
				assert(not isMatch("aaa/bbb", "*/*/*"))
				assert(not isMatch("ab/zzz/ejkl/hi", "*/*jk*/*i"))
				assert(isMatch("aaa/bba/ccc", "*/*/*"))
				assert(isMatch("aaa/bba/ccc", "aaa/**"))
				assert(isMatch("aaa/bbb", "aaa/*"))
				assert(isMatch("ab/zzz/ejkl/hi", "*/*z*/*/*i"))
				assert(isMatch("abzzzejklhi", "*j*i"))
			end)

			it("should support single globs (*)", function()
				assert(isMatch("a", "*"))
				assert(isMatch("b", "*"))
				assert(not isMatch("a/a", "*"))
				assert(not isMatch("a/a/a", "*"))
				assert(not isMatch("a/a/b", "*"))
				assert(not isMatch("a/a/a/a", "*"))
				assert(not isMatch("a/a/a/a/a", "*"))
				assert(not isMatch("a", "*/*"))
				assert(isMatch("a/a", "*/*"))
				assert(not isMatch("a/a/a", "*/*"))
				assert(not isMatch("a", "*/*/*"))
				assert(not isMatch("a/a", "*/*/*"))
				assert(isMatch("a/a/a", "*/*/*"))
				assert(not isMatch("a/a/a/a", "*/*/*"))
				assert(not isMatch("a", "*/*/*/*"))
				assert(not isMatch("a/a", "*/*/*/*"))
				assert(not isMatch("a/a/a", "*/*/*/*"))
				assert(isMatch("a/a/a/a", "*/*/*/*"))
				assert(not isMatch("a/a/a/a/a", "*/*/*/*"))
				assert(not isMatch("a", "*/*/*/*/*"))
				assert(not isMatch("a/a", "*/*/*/*/*"))
				assert(not isMatch("a/a/a", "*/*/*/*/*"))
				assert(not isMatch("a/a/b", "*/*/*/*/*"))
				assert(not isMatch("a/a/a/a", "*/*/*/*/*"))
				assert(isMatch("a/a/a/a/a", "*/*/*/*/*"))
				assert(not isMatch("a/a/a/a/a/a", "*/*/*/*/*"))
				assert(not isMatch("a", "a/*"))
				assert(isMatch("a/a", "a/*"))
				assert(not isMatch("a/a/a", "a/*"))
				assert(not isMatch("a/a/a/a", "a/*"))
				assert(not isMatch("a/a/a/a/a", "a/*"))
				assert(not isMatch("a", "a/*/*"))
				assert(not isMatch("a/a", "a/*/*"))
				assert(isMatch("a/a/a", "a/*/*"))
				assert(not isMatch("b/a/a", "a/*/*"))
				assert(not isMatch("a/a/a/a", "a/*/*"))
				assert(not isMatch("a/a/a/a/a", "a/*/*"))
				assert(not isMatch("a", "a/*/*/*"))
				assert(not isMatch("a/a", "a/*/*/*"))
				assert(not isMatch("a/a/a", "a/*/*/*"))
				assert(isMatch("a/a/a/a", "a/*/*/*"))
				assert(not isMatch("a/a/a/a/a", "a/*/*/*"))
				assert(not isMatch("a", "a/*/*/*/*"))
				assert(not isMatch("a/a", "a/*/*/*/*"))
				assert(not isMatch("a/a/a", "a/*/*/*/*"))
				assert(not isMatch("a/a/b", "a/*/*/*/*"))
				assert(not isMatch("a/a/a/a", "a/*/*/*/*"))
				assert(isMatch("a/a/a/a/a", "a/*/*/*/*"))
				assert(not isMatch("a", "a/*/a"))
				assert(not isMatch("a/a", "a/*/a"))
				assert(isMatch("a/a/a", "a/*/a"))
				assert(not isMatch("a/a/b", "a/*/a"))
				assert(not isMatch("a/a/a/a", "a/*/a"))
				assert(not isMatch("a/a/a/a/a", "a/*/a"))
				assert(not isMatch("a", "a/*/b"))
				assert(not isMatch("a/a", "a/*/b"))
				assert(not isMatch("a/a/a", "a/*/b"))
				assert(isMatch("a/a/b", "a/*/b"))
				assert(not isMatch("a/a/a/a", "a/*/b"))
				assert(not isMatch("a/a/a/a/a", "a/*/b"))
			end)

			it("should only match a single folder per star when globstars are used", function()
				assert(not isMatch("a", "*/**/a"))
				assert(not isMatch("a/a/b", "*/**/a"))
				assert(isMatch("a/a", "*/**/a"))
				assert(isMatch("a/a/a", "*/**/a"))
				assert(isMatch("a/a/a/a", "*/**/a"))
				assert(isMatch("a/a/a/a/a", "*/**/a"))
			end)

			it("should not match a trailing slash when a star is last char", function()
				assert(not isMatch("a", "*/"))
				assert(not isMatch("a", "*/*"))
				assert(not isMatch("a", "a/*"))
				assert(not isMatch("a/", "*/*"))
				assert(not isMatch("a/", "a/*"))
				assert(not isMatch("a/a", "*"))
				assert(not isMatch("a/a", "*/"))
				assert(not isMatch("a/x/y", "*/"))
				assert(not isMatch("a/x/y", "*/*"))
				assert(not isMatch("a/x/y", "a/*"))
				assert(not isMatch("a/", "*", { strictSlashes = true }))
				assert(isMatch("a/", "*"))
				assert(isMatch("a", "*"))
				assert(isMatch("a/", "*/"))
				assert(isMatch("a/", "*{,/}"))
				assert(isMatch("a/a", "*/*"))
				assert(isMatch("a/a", "a/*"))
			end)

			it("should work with file extensions", function()
				assert(not isMatch("a.txt", "a/**/*.txt"))
				assert(isMatch("a/x/y.txt", "a/**/*.txt"))
				assert(not isMatch("a/x/y/z", "a/**/*.txt"))
				assert(not isMatch("a.txt", "a/*.txt"))
				assert(isMatch("a/b.txt", "a/*.txt"))
				assert(not isMatch("a/x/y.txt", "a/*.txt"))
				assert(not isMatch("a/x/y/z", "a/*.txt"))
				assert(isMatch("a.txt", "a*.txt"))
				assert(not isMatch("a/b.txt", "a*.txt"))
				assert(not isMatch("a/x/y.txt", "a*.txt"))
				assert(not isMatch("a/x/y/z", "a*.txt"))
				assert(isMatch("a.txt", "*.txt"))
				assert(not isMatch("a/b.txt", "*.txt"))
				assert(not isMatch("a/x/y.txt", "*.txt"))
				assert(not isMatch("a/x/y/z", "*.txt"))
			end)

			it("should not match slashes when globstars are not exclusive in a path segment", function()
				assert(not isMatch("foo/baz/bar", "foo**bar"))
				assert(isMatch("foobazbar", "foo**bar"))
			end)

			it("should match slashes when defined in braces", function()
				assert(isMatch("foo", "foo{,/**}"))
			end)

			it("should correctly match slashes", function()
				assert(not isMatch("a/b", "a*"))
				assert(not isMatch("a/a/bb", "a/**/b"))
				assert(not isMatch("a/bb", "a/**/b"))
				assert(not isMatch("foo", "*/**"))
				assert(not isMatch("foo/bar", "**/"))
				assert(not isMatch("foo/bar", "**/*/"))
				assert(not isMatch("foo/bar", "*/*/"))
				assert(not isMatch("foo/bar/", "**/*", { strictSlashes = true }))
				assert(isMatch("/home/foo/..", "**/.."))
				assert(isMatch("a", "**/a"))
				assert(isMatch("a/a", "**"))
				assert(isMatch("a/a", "a/**"))
				assert(isMatch("a/", "a/**"))
				assert(isMatch("a", "a/**"))
				assert(not isMatch("a/a", "**/"))
				assert(isMatch("a", "**/a/**"))
				assert(isMatch("a", "a/**"))
				assert(not isMatch("a/a", "**/"))
				assert(isMatch("a/a", "*/**/a"))
				assert(isMatch("a", "a/**"))
				assert(isMatch("foo/", "*/**"))
				assert(isMatch("foo/bar", "**/*"))
				assert(isMatch("foo/bar", "*/*"))
				assert(isMatch("foo/bar", "*/**"))
				assert(isMatch("foo/bar/", "**/"))
				assert(isMatch("foo/bar/", "**/*"))
				assert(isMatch("foo/bar/", "**/*/"))
				assert(isMatch("foo/bar/", "*/**"))
				assert(isMatch("foo/bar/", "*/*/"))
				assert(not isMatch("bar/baz/foo", "*/foo"))
				assert(not isMatch("deep/foo/bar", "**/bar/*"))
				assert(not isMatch("deep/foo/bar/baz/x", "*/bar/**"))
				assert(not isMatch("ef", "/*"))
				assert(not isMatch("foo/bar", "foo?bar"))
				assert(not isMatch("foo/bar/baz", "**/bar*"))
				assert(not isMatch("foo/bar/baz", "**/bar**"))
				assert(not isMatch("foo/baz/bar", "foo**bar"))
				assert(not isMatch("foo/baz/bar", "foo*bar"))
				assert(isMatch("foo", "foo/**"))
				assert(isMatch("/ab", "/*"))
				assert(isMatch("/cd", "/*"))
				assert(isMatch("/ef", "/*"))
				assert(isMatch("a/b/j/c/z/x.md", "a/**/j/**/z/*.md"))
				assert(isMatch("a/j/z/x.md", "a/**/j/**/z/*.md"))
				assert(isMatch("bar/baz/foo", "**/foo"))
				assert(isMatch("deep/foo/bar/baz", "**/bar/*"))
				assert(isMatch("deep/foo/bar/baz/", "**/bar/**"))
				assert(isMatch("deep/foo/bar/baz/x", "**/bar/*/*"))
				assert(isMatch("foo/b/a/z/bar", "foo/**/**/bar"))
				assert(isMatch("foo/b/a/z/bar", "foo/**/bar"))
				assert(isMatch("foo/bar", "foo/**/**/bar"))
				assert(isMatch("foo/bar", "foo/**/bar"))
				assert(isMatch("foo/bar/baz/x", "*/bar/**"))
				assert(isMatch("foo/baz/bar", "foo/**/**/bar"))
				assert(isMatch("foo/baz/bar", "foo/**/bar"))
				assert(isMatch("XXX/foo", "**/foo"))
			end)

			it('should ignore leading "./" when defined on pattern', function()
				assert(isMatch("ab", "./*"))
				assert(not isMatch("ab", "./*/"))
				assert(isMatch("ab/", "./*/"))
			end)

			it("should optionally match trailing slashes with braces", function()
				assert(isMatch("foo", "**/*"))
				assert(isMatch("foo", "**/*{,/}"))
				assert(isMatch("foo/", "**/*{,/}"))
				assert(isMatch("foo/bar", "**/*{,/}"))
				assert(isMatch("foo/bar/", "**/*{,/}"))
			end)
		end)
	end)
end
