-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/test/braces.js

return function()
	local CurrentModule = script.Parent
	local PicomatchModule = CurrentModule.Parent
	local Packages = PicomatchModule.Parent

	local jestExpect = require(Packages.Dev.Expect)

	-- ROBLOX deviation: not supported in Lua
	-- local fill = require("fill-range")
	local match = require(CurrentModule.support.match)
	local isMatch = require(PicomatchModule).isMatch
	describe("braces", function()
		itFIXME("should not match with brace patterns when disabled", function()
			jestExpect(match({ "a", "b", "c" }, "{a,b,c,d}")).toEqual({ "a", "b", "c" })
			jestExpect(match({ "a", "b", "c" }, "{a,b,c,d}", { nobrace = true })).toEqual({})
			jestExpect(match({ "1", "2", "3" }, "{1..2}", { nobrace = true })).toEqual({})
			assert(not isMatch("a/a", "a/{a,b}", { nobrace = true }))
			assert(not isMatch("a/b", "a/{a,b}", { nobrace = true }))
			assert(not isMatch("a/c", "a/{a,b}", { nobrace = true }))
			assert(not isMatch("b/b", "a/{a,b}", { nobrace = true }))
			assert(not isMatch("b/b", "a/{a,b,c}", { nobrace = true }))
			assert(not isMatch("a/c", "a/{a,b,c}", { nobrace = true }))
			assert(not isMatch("a/a", "a/{a..c}", { nobrace = true }))
			assert(not isMatch("a/b", "a/{a..c}", { nobrace = true }))
			assert(not isMatch("a/c", "a/{a..c}", { nobrace = true }))
		end)

		it("should treat single-set braces as literals", function()
			assert(isMatch("a {abc} b", "a {abc} b"))
			assert(isMatch("a {a-b-c} b", "a {a-b-c} b"))
			assert(isMatch("a {a.c} b", "a {a.c} b"))
		end)

		it("should match literal braces when escaped", function()
			assert(isMatch("a {1,2}", "a \\{1,2\\}"))
			assert(isMatch("a {a..b}", "a \\{a..b\\}"))
		end)

		it("should match using brace patterns", function()
			assert(not isMatch("a/c", "a/{a,b}"))
			assert(not isMatch("b/b", "a/{a,b,c}"))
			assert(not isMatch("b/b", "a/{a,b}"))
			assert(isMatch("a/a", "a/{a,b}"))
			assert(isMatch("a/b", "a/{a,b}"))
			assert(isMatch("a/c", "a/{a,b,c}"))
		end)

		it("should support brace ranges", function()
			assert(isMatch("a/a", "a/{a..c}"))
			assert(isMatch("a/b", "a/{a..c}"))
			assert(isMatch("a/c", "a/{a..c}"))
		end)

		it("should support Kleene stars", function()
			assert(isMatch("ab", "{ab,c}*"))
			assert(isMatch("abab", "{ab,c}*"))
			assert(isMatch("abc", "{ab,c}*"))
			assert(isMatch("c", "{ab,c}*"))
			assert(isMatch("cab", "{ab,c}*"))
			assert(isMatch("cc", "{ab,c}*"))
			assert(isMatch("ababab", "{ab,c}*"))
			assert(isMatch("ababc", "{ab,c}*"))
			assert(isMatch("abcab", "{ab,c}*"))
			assert(isMatch("abcc", "{ab,c}*"))
			assert(isMatch("cabab", "{ab,c}*"))
			assert(isMatch("cabc", "{ab,c}*"))
			assert(isMatch("ccab", "{ab,c}*"))
			assert(isMatch("ccc", "{ab,c}*"))
		end)

		itFIXME("should not convert braces inside brackets", function()
			assert(isMatch("foo{}baz", "foo[{a,b}]+baz"))
			assert(isMatch("{a}{b}{c}", "[abc{}]+"))
		end)

		it("should support braces containing slashes", function()
			assert(isMatch("a", "{/,}a/**"))
			assert(isMatch("aa.txt", "a{a,b/}*.txt"))
			assert(isMatch("ab/.txt", "a{a,b/}*.txt"))
			assert(isMatch("ab/a.txt", "a{a,b/}*.txt"))
			assert(isMatch("a/", "a/**{/,}"))
			assert(isMatch("a/a", "a/**{/,}"))
			assert(isMatch("a/a/", "a/**{/,}"))
		end)

		it("should support braces with empty elements", function()
			assert(not isMatch("abc.txt", "a{,b}.txt"))
			assert(not isMatch("abc.txt", "a{a,b,}.txt"))
			assert(not isMatch("abc.txt", "a{b,}.txt"))
			assert(isMatch("a.txt", "a{,b}.txt"))
			assert(isMatch("a.txt", "a{b,}.txt"))
			assert(isMatch("aa.txt", "a{a,b,}.txt"))
			assert(isMatch("aa.txt", "a{a,b,}.txt"))
			assert(isMatch("ab.txt", "a{,b}.txt"))
			assert(isMatch("ab.txt", "a{b,}.txt"))
		end)

		it("should support braces with slashes and empty elements", function()
			assert(isMatch("a.txt", "a{,/}*.txt"))
			assert(isMatch("ab.txt", "a{,/}*.txt"))
			assert(isMatch("a/b.txt", "a{,/}*.txt"))
			assert(isMatch("a/ab.txt", "a{,/}*.txt"))
		end)

		it("should support braces with stars", function()
			assert(isMatch("a.txt", "a{,.*{foo,db},\\(bar\\)}.txt"))
			assert(not isMatch("adb.txt", "a{,.*{foo,db},\\(bar\\)}.txt"))
			assert(isMatch("a.db.txt", "a{,.*{foo,db},\\(bar\\)}.txt"))
			assert(isMatch("a.txt", "a{,*.{foo,db},\\(bar\\)}.txt"))
			assert(not isMatch("adb.txt", "a{,*.{foo,db},\\(bar\\)}.txt"))
			assert(isMatch("a.db.txt", "a{,*.{foo,db},\\(bar\\)}.txt"))
			assert(isMatch("a", "a{,.*{foo,db},\\(bar\\)}"))
			assert(not isMatch("adb", "a{,.*{foo,db},\\(bar\\)}"))
			assert(isMatch("a.db", "a{,.*{foo,db},\\(bar\\)}"))
			assert(isMatch("a", "a{,*.{foo,db},\\(bar\\)}"))
			assert(not isMatch("adb", "a{,*.{foo,db},\\(bar\\)}"))
			assert(isMatch("a.db", "a{,*.{foo,db},\\(bar\\)}"))
			assert(not isMatch("a", "{,.*{foo,db},\\(bar\\)}"))
			assert(not isMatch("adb", "{,.*{foo,db},\\(bar\\)}"))
			assert(not isMatch("a.db", "{,.*{foo,db},\\(bar\\)}"))
			assert(isMatch(".db", "{,.*{foo,db},\\(bar\\)}"))
			assert(not isMatch("a", "{,*.{foo,db},\\(bar\\)}"))
			assert(isMatch("a", "{*,*.{foo,db},\\(bar\\)}"))
			assert(not isMatch("adb", "{,*.{foo,db},\\(bar\\)}"))
			assert(isMatch("a.db", "{,*.{foo,db},\\(bar\\)}"))
		end)

		it("should support braces in patterns with globstars", function()
			assert(not isMatch("a/b/c/xyz.md", "a/b/**/c{d,e}/**/xyz.md"))
			assert(not isMatch("a/b/d/xyz.md", "a/b/**/c{d,e}/**/xyz.md"))
			assert(isMatch("a/b/cd/xyz.md", "a/b/**/c{d,e}/**/xyz.md"))
			assert(isMatch("a/b/c/xyz.md", "a/b/**/{c,d,e}/**/xyz.md"))
			assert(isMatch("a/b/d/xyz.md", "a/b/**/{c,d,e}/**/xyz.md"))
		end)

		it("should support braces with globstars, slashes and empty elements", function()
			assert(isMatch("a.txt", "a{,/**/}*.txt"))
			assert(isMatch("a/b.txt", "a{,/**/,/}*.txt"))
			assert(isMatch("a/x/y.txt", "a{,/**/}*.txt"))
			assert(not isMatch("a/x/y/z", "a{,/**/}*.txt"))
		end)

		it("should support braces with globstars and empty elements", function()
			assert(isMatch("a/b/foo/bar/baz.qux", "a/b{,/**}/bar{,/**}/*.*"))
			assert(isMatch("a/b/bar/baz.qux", "a/b{,/**}/bar{,/**}/*.*"))
		end)

		it("should support Kleene plus", function()
			assert(isMatch("ab", "{ab,c}+"))
			assert(isMatch("abab", "{ab,c}+"))
			assert(isMatch("abc", "{ab,c}+"))
			assert(isMatch("c", "{ab,c}+"))
			assert(isMatch("cab", "{ab,c}+"))
			assert(isMatch("cc", "{ab,c}+"))
			assert(isMatch("ababab", "{ab,c}+"))
			assert(isMatch("ababc", "{ab,c}+"))
			assert(isMatch("abcab", "{ab,c}+"))
			assert(isMatch("abcc", "{ab,c}+"))
			assert(isMatch("cabab", "{ab,c}+"))
			assert(isMatch("cabc", "{ab,c}+"))
			assert(isMatch("ccab", "{ab,c}+"))
			assert(isMatch("ccc", "{ab,c}+"))
			assert(isMatch("ccc", "{a,b,c}+"))
			assert(isMatch("a", "{a,b,c}+"))
			assert(isMatch("b", "{a,b,c}+"))
			assert(isMatch("c", "{a,b,c}+"))
			assert(isMatch("aa", "{a,b,c}+"))
			assert(isMatch("ab", "{a,b,c}+"))
			assert(isMatch("ac", "{a,b,c}+"))
			assert(isMatch("ba", "{a,b,c}+"))
			assert(isMatch("bb", "{a,b,c}+"))
			assert(isMatch("bc", "{a,b,c}+"))
			assert(isMatch("ca", "{a,b,c}+"))
			assert(isMatch("cb", "{a,b,c}+"))
			assert(isMatch("cc", "{a,b,c}+"))
			assert(isMatch("aaa", "{a,b,c}+"))
			assert(isMatch("aab", "{a,b,c}+"))
			assert(isMatch("abc", "{a,b,c}+"))
		end)

		it("should support braces", function()
			assert(isMatch("a", "{a,b,c}"))
			assert(isMatch("b", "{a,b,c}"))
			assert(isMatch("c", "{a,b,c}"))
			assert(not isMatch("aa", "{a,b,c}"))
			assert(not isMatch("bb", "{a,b,c}"))
			assert(not isMatch("cc", "{a,b,c}"))
		end)
		-- ROBLOX deviation START: not supported in Lua
		itSKIP("should match special chars and expand ranges in parentheses", function()
			-- local function expandRange(a, b)
			-- 	return ("(%s)"):format(fill(a, b, { toRegex = true }))
			-- end
			-- assert(not isMatch("foo/bar - 1", "*/* {4..10}", { expandRange = expandRange }))
			-- assert(
			-- 	not Boolean.toJSBoolean(
			-- 		isMatch("foo/bar - copy (1)", "*/* - * \\({4..10}\\)", { expandRange = expandRange })
			-- 	)
			-- )
			-- assert(not isMatch("foo/bar (1)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar (4)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar (7)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(not isMatch("foo/bar (42)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar (42)", "*/* \\({4..43}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar - copy [1]", "*/* \\[{0..5}\\]", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar - foo + bar - copy [1]", "*/* \\[{0..5}\\]", { expandRange = expandRange }))
			-- assert(not isMatch("foo/bar - 1", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(
			-- 	not Boolean.toJSBoolean(
			-- 		isMatch("foo/bar - copy (1)", "*/* \\({4..10}\\)", { expandRange = expandRange })
			-- 	)
			-- )
			-- assert(not isMatch("foo/bar (1)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar (4)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(isMatch("foo/bar (7)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(not isMatch("foo/bar (42)", "*/* \\({4..10}\\)", { expandRange = expandRange }))
			-- assert(
			-- 	not Boolean.toJSBoolean(
			-- 		isMatch("foo/bar - copy [1]", "*/* \\({4..10}\\)", { expandRange = expandRange })
			-- 	)
			-- )
			-- assert(
			-- 	not Boolean.toJSBoolean(
			-- 		isMatch("foo/bar - foo + bar - copy [1]", "*/* \\({4..10}\\)", { expandRange = expandRange })
			-- 	)
			-- )
		end)
		-- ROBLOX deviation END
	end)
end
